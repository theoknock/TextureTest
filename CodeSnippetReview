/* Anonymous block pointers (in-progress) */

typedef double (^D)(int);
D d = ^ double (int m) {
    return (double)m;
};

typedef int (^M)(double);
M m = ^ int (double d) {
    return (int)d;
};

typedef void * BlkPtr;
BlkPtr blk_d_ptr = &d;
BlkPtr blk_m_ptr = &m;

/* */

/* reduction function */

static void (^(^(^reduce)(UIButton * _Nonnull __strong *))(UIButton *(^__strong)(UIButton *__strong, unsigned int)))(UIButton *(^__strong)(UIButton * _Nonnull __strong, unsigned int)) =
^ (__strong UIButton * _Nonnull button_collection[5]) {
    dispatch_queue_t enumerator_queue  = dispatch_queue_create("enumerator_queue", DISPATCH_QUEUE_SERIAL);
    return ^ (void *(^reduction)(UIButton *, unsigned int)) {
        return ^ (UIButton * (^reductor)(UIButton * _Nonnull, unsigned int)) {
            dispatch_barrier_async(dispatch_get_main_queue(), ^{
                dispatch_apply(5, enumerator_queue, ^(size_t index) {
                    dispatch_barrier_async(dispatch_get_main_queue(), ^{
                        reduction(reductor(button_collection[index], (unsigned int)index), (unsigned int)index);
                    });
                });
            });
        };
    };
};

= ^ (__strong UIButton * _Nonnull button_collection[5]) {
    return ^ (void(^b)(UIButton * _Nonnull)) {
        return ^ (UIButton *(^c)(unsigned int)) {
        };
    };
};

static void (^reduce)(void) = ^{
    state();
    filter(buttons)(^ (UIButton * _Nonnull button, unsigned int property) {
        printf("\n%lu\tstate\t%s\t\t", button.tag, (state_bits & (1 << property)) ? "TRUE" : "FALSE");
        printf("%lu\tselected\t%s\t\t", button.tag, (selected_bits & (1 << property)) ? "TRUE" : "FALSE");
        printf("%lu\tenabled\t%s\n", button.tag, (enabled_bits & (1 << property)) ? "TRUE" : "FALSE");
        [button setSelected:(selected_bits & (1 << property)) ? TRUE : FALSE];
        [button setHidden:(enabled_bits & (1 << property)) ? FALSE : TRUE];
    });
};

/* */

/* Is nth bit masked */

bool nth_is_set = (v & (1 << n)) != 0;
bool nth_is_set = (v >> n) & 1;

/* */

/* Core Haptics failure */

@property (nonatomic, assign) BOOL supportsHaptics;
@property (nonatomic, strong) CHHapticEngine* engine;
@property (nonatomic, strong) id<CHHapticPatternPlayer> player;

    self.supportsHaptics = CHHapticEngine.capabilitiesForHardware.supportsHaptics;
    printf("CHHapticEngine %s\n", (self.supportsHaptics) ? "supported" : "not supported");
    __autoreleasing NSError* error = nil;
    _engine = [[CHHapticEngine alloc] initAndReturnError:&error];
    printf("%s\n", (error) ? [error.localizedDescription UTF8String] : "Initialized CHHapticEngine");
    hapticDict =
        @{
         CHHapticPatternKeyPattern:
               @[ // Start of array
                 @{  // Start of first dictionary entry in the array
                     CHHapticPatternKeyEvent: @{ // Start of first item
                             CHHapticPatternKeyEventType:CHHapticEventTypeHapticTransient,
                             CHHapticPatternKeyTime:@0.5,
                             CHHapticPatternKeyEventDuration:@1.0
                             },  // End of first item
                   }, // End of first dictionary entry in the array
                ], // End of array
         }; // End of haptic dictionary

    CHHapticPattern* pattern = [[CHHapticPattern alloc] initWithDictionary:hapticDict error:&error];
    _player = [_engine createPlayerWithPattern:pattern error:&error];
    __weak ControlView * w_control_view = self;
    [_engine setResetHandler:^{
        NSLog(@"Engine RESET!");
        // Try restarting the engine again.
        __autoreleasing NSError* error = nil;
        [w_control_view.engine startAndReturnError:&error];
        if (error) {
            NSLog(@"ERROR: Engine couldn't restart!");
        }
        _player = [_engine createPlayerWithPattern:pattern error:&error];
    }];
    [_engine setStoppedHandler:^(CHHapticEngineStoppedReason reason){
        NSLog(@"Engine STOPPED!");
        switch (reason)
        {
            case CHHapticEngineStoppedReasonAudioSessionInterrupt: {
                NSLog(@"REASON: Audio Session Interrupt");
                // A phone call or notification could have come in, so take note to restart the haptic engine after the call ends. Wait for user-initiated playback.
                break;
            }
            case CHHapticEngineStoppedReasonApplicationSuspended: {
                NSLog(@"REASON: Application Suspended");
                // The user could have backgrounded your app, so take note to restart the haptic engine when the app reenters the foreground. Wait for user-initiated playback.
                break;
            }
            case CHHapticEngineStoppedReasonIdleTimeout: {
                NSLog(@"REASON: Idle Timeout");
                // The system stopped an idle haptic engine to conserve power, so restart it before your app must play the next haptic pattern.
                break;
            }
            case CHHapticEngineStoppedReasonNotifyWhenFinished: {
                printf("CHHapticEngineStoppedReasonNotifyWhenFinished\n");
                break;
            }
            case CHHapticEngineStoppedReasonEngineDestroyed: {
                printf("CHHapticEngineStoppedReasonEngineDestroyed\n");
                break;
            }
            case CHHapticEngineStoppedReasonGameControllerDisconnect: {
                printf("CHHapticEngineStoppedReasonGameControllerDisconnect\n");
                break;
            }
            case CHHapticEngineStoppedReasonSystemError: {
                NSLog(@"REASON: System Error");
                // The system faulted, so either continue without haptics or terminate the app.
                break;
            }
        }
    }];

    [_engine startWithCompletionHandler:^(NSError* returnedError) {
        if (returnedError)
            NSLog(@"--- Error starting haptic engine: %@", returnedError.debugDescription);
    }];

    [_player startAtTime:CHHapticTimeImmediate error:&error];

    [_engine stopWithCompletionHandler:^(NSError* _Nullable error) {
        if (error)
            NSLog(@"--- Error stopping haptic engine: %@", error.debugDescription);
    }];

/*
 
 */


static void (^(^(^(^(^(^(^(^draw_control_init)(__nullable dispatch_block_t))(ArcControlMeasurements * const))(ControlView *__strong))(CGRect))(CAShapeLayer *__strong))(CGContextRef __nullable))(TouchEventHandlerType))(UITouch *);
static void (^(^(^(^(^(^(^draw_control)(ArcControlMeasurements * const))(ControlView *__strong))(CGRect))(CAShapeLayer *__strong))(CGContextRef __nullable))(TouchEventHandlerType))(UITouch *);
static void (^(^(^(^(^(^draw_primary_component_init)(ControlView *__strong))(CGRect))(CAShapeLayer *__strong))(CGContextRef __nullable))(TouchEventHandlerType))(UITouch *);
static void (^(^(^(^(^draw_primary_component)(CGRect))(CAShapeLayer *__strong))(CGContextRef __nullable))(TouchEventHandlerType))(UITouch *);
static void (^(^(^(^draw_secondary_component_init)(CAShapeLayer *__strong))(CGContextRef __nullable))(TouchEventHandlerType))(UITouch *);
static void (^(^(^draw_secondary_component)(CGContextRef __nullable))(TouchEventHandlerType))(UITouch *);
static void (^(^handle_touch_control_event_init)(TouchEventHandlerType))(UITouch *);
static void (^handle_touch_control_event[TouchEventHandlerTypeDefault])(UITouch *);

static void (^(^(^(^(^(^(^(^draw_control_init)(__nullable dispatch_block_t))(ArcControlMeasurements * const))(ControlView *__strong))(CGRect))(CAShapeLayer *__strong))(CGContextRef __nullable))(TouchEventHandlerType))(UITouch *) =


^ (dispatch_block_t init) {
    if (init) init();
    return (^ (ArcControlMeasurements * const measurements) {
        return (^ (ControlView * view) {
            return (^ (CGRect rect) {
                UIButton * (^CaptureDeviceConfigurationPropertyButton)(CaptureDeviceConfigurationControlProperty) = CaptureDeviceConfigurationPropertyButtons(CaptureDeviceConfigurationControlPropertyImageValues, view);
                for (CaptureDeviceConfigurationControlProperty property = CaptureDeviceConfigurationControlPropertyTorchLevel; property <= CaptureDeviceConfigurationControlPropertyZoomFactor; property++) {
                    UIButton * button = CaptureDeviceConfigurationPropertyButton(property);
                    CGPoint center = CGPointMake(CGRectGetMidX(rect), CGRectGetMidY(rect));
                    CGFloat radius = (center.x);
//                    double x = (center.x + (radius * -cosf(2.0 * M_PI_4 * ((property) / 4.0))));
//                    double y = (center.y + (radius * -sinf(2.0 * M_PI_4 * ((property) / 4.0))));
                    double angle = 180.0 + (90.0 * ((property) / 4.0));
                    UIBezierPath * bezier_quad_curve = [UIBezierPath bezierPathWithArcCenter:CGPointMake(CGRectGetMaxX(rect), CGRectGetMaxY(rect))
                                                                                      radius:radius
                                                                                  startAngle:degreesToRadians(angle) endAngle:degreesToRadians(angle)
                                                                                   clockwise:FALSE];
                    
                    [button setCenter:[bezier_quad_curve currentPoint]];
                    static dispatch_once_t onceToken[5];
                    dispatch_once(&onceToken[property], ^{
                        [view addSubview:button];
                    });
                }
                return (^ (CAShapeLayer * __strong layer) {
                    return (^ (CGContextRef __nullable context) {
                        return (^ (TouchEventHandlerType touch_event_handler_type) {
                            [layer setLineWidth:1.0];
                            UIColor * stroke_color = (touch_event_handler_type == TouchEventHandlerTypeTouchesBegan)
                            ? [UIColor yellowCollor] : (touch_event_handler_type == TouchEventHandlerTypeTouchesMoved)
                            ? [UIColor systemGreenColor] : [UIColor blueCollor];
                            [layer setStrokeColor:stroke_color.CGColor];
                            [layer setFillColor:[UIColor clearColor].CGColor];
                            [layer setBackgroundColor:[UIColor clearColor].CGColor];
                            void(^touch_event_handler)(UITouch *) = ^ (UITouch * touch) {
                                CGPoint center = CGPointMake(CGRectGetMaxX(rect), CGRectGetMaxY(rect));
                                CGFloat radius = (center.x);
                                CGPoint touch_point = [touch preciseLocationInView:touch.view];
                                CGPoint tp = touch_point;/* CGPointMake(rescale(fmaxf(CGRectGetMinX(rect), fminf(CGRectGetMaxX(rect), touch_point.x)), CGRectGetMinX(rect), CGRectGetMaxX(rect), 0.0, 360.0),
                                                         rescale(fmaxf(CGRectGetMinY(rect), fminf(CGRectGetMaxY(rect), touch_point.y)), CGRectGetMinY(rect), CGRectGetMaxY(rect), 0.0, 360.0));*/
                                radius = sqrt(pow(tp.x - center.x, 2.0) + pow(tp.y - center.y, 2.0));
                                UIBezierPath * bezier_quad_curve = [UIBezierPath bezierPathWithArcCenter:CGPointMake(CGRectGetMaxX(rect), CGRectGetMaxY(rect))
                                                                                                  radius:radius
                                                                                              startAngle:degreesToRadians(270.0) endAngle:degreesToRadians(180.0)
                                                                                               clockwise:FALSE];
                                [layer setPath:bezier_quad_curve.CGPath];
                            };
                            void(^touch_event_handlers[3])(UITouch *) = {touch_event_handler, touch_event_handler, touch_event_handler};
                            return touch_event_handlers[1];
                        });
                    });
                });
            });
        });
    });
};

 //                /* _Atomic */ __block CFMutableBitVectorRef active_component_bits = CFBitVectorCreateMutable(kCFAllocatorDefault, 5);__block
 //                 unsigned int duration_midpoint = 15;
 //                __block long pre_animation_frame_count = ((~(1UL << duration_midpoint + 1) & (-(~(1UL << duration_midpoint + 1)))) << duration_midpoint + 1) - 1;  //
 //                /* _Atomic */ __block long active_component_bit_mask = ~active_component_bit_vector;
 //
 //                /* _Atomic */ CFMutableBitVectorRef selected = CFBitVectorCreateMutable(kCFAllocatorDefault, 5);
 //                bit_vector_ref(&selected, 5)(^ (uint32_t position) {
 //                    CFBit bit = (floor(log2(selected_property_bit_vector)) == position);
 //                    return bit;
 //                });
 //                /* _Atomic */ CFMutableBitVectorRef indicies = CFBitVectorCreateMutable(kCFAllocatorDefault, 5);
 //                integrate((long)30)(^ (long frame) {
 //                    pre_animation_frame_count >>= 1UL;
 //                    active_component_bit_mask = (((pre_animation_frame_count >> 0) & 1UL) << 0) ^ (((active_component_bit_vector >> 0) & 1UL) << 0);
 //                    bit_vector_ref(&active_component_bits, 5)(^ (uint32_t position) {
 //                        CFBit bit = (UInt32)(active_component_bit_mask & BUTTON_ARC_COMPONENT_BIT_MASK);
 //                        return bit;
 //                    });
 //
 //                    //                      printf("H: %d\t\tF: %ld\t\tS: %d\t\tA: %d\n", isBitSet(pre_animation_frame_count, 0), frame, isBitSet(active_component_bit_vector, 0), isBitSet((active_component_bit_mask & BUTTON_ARC_COMPONENT_BIT_MASK), 0));
 //                    float angle_adj = (360.0 / 30.0) * frame;
 //                    bit_vector_ref(&indicies, 5)(^ (uint32_t position) {
 //                        CFBit bit = (UInt32)((active_component_bit_mask >> 0) & 1UL) ^ !!(floor(log2(selected_property_bit_vector)) == position) ^ (((pre_animation_frame_count >> 0) & 1UL) << 0);
 //                        return bit;
 //                    });
 //                    return (^{
 //                        dispatch_barrier_async(dispatch_get_main_queue(), ^{
 //                            draw_button_arc(indicies, angle_adj);
 //                        });
 //                        return ^{
 //                            return (long)indicies;
 //                        };
 //                    }()());
 //
 //                });
 //
 //                return (^{
 //                    dispatch_barrier_async(dispatch_get_main_queue(), ^{
 //                        draw_button_arc(bit_vector_ref(&active_component_bit_vector_ref, 5)(^ (uint32_t position) {
 //                            CFBit bit = (UInt32)((active_component_bit_vector >> 0) & 1UL) ^ !!(floor(log2(selected_property_bit_vector)) == position);
 //                            return bit;
 //                        }), 0.0f);
 //                    });
 //                    return ^{
 //                        return (long)active_component_bit_vector_ref;
 //                    };
 //                }()());


__block volatile atomic_uint_fast8_t touch_property = ATOMIC_VAR_INIT(0);
typeof(touch_property) * touch_property_t = &touch_property;

uint_fast8_t current_touch_property     = (unsigned long)round(rescale(position_angle, 180.0, 270.0, 0.0, 4.0));
uint_fast8_t * current_touch_property_t = &current_touch_property;

atomic_compare_exchange_weak(touch_property_t, new_touch_property_t, new_touch_property); // atomic_exchange(touch_property_t, new_touch_property) ^ new_touch_property);
OSAtomicCompareAndSwapLong((highlighted_property_bit_vector << touch_property), (highlighted_property_bit_vector << new_touch_property), &touch_property);
