/* Anonymous block pointers (in-progress) */

typedef double (^D)(int);
D d = ^ double (int m) {
    return (double)m;
};

typedef int (^M)(double);
M m = ^ int (double d) {
    return (int)d;
};

typedef void * BlkPtr;
BlkPtr blk_d_ptr = &d;
BlkPtr blk_m_ptr = &m;

/* */

/* reduction function */

static void (^(^(^reduce)(UIButton * _Nonnull __strong *))(UIButton *(^__strong)(UIButton *__strong, unsigned int)))(UIButton *(^__strong)(UIButton * _Nonnull __strong, unsigned int)) =
^ (__strong UIButton * _Nonnull button_collection[5]) {
    dispatch_queue_t enumerator_queue  = dispatch_queue_create("enumerator_queue", DISPATCH_QUEUE_SERIAL);
    return ^ (void *(^reduction)(UIButton *, unsigned int)) {
        return ^ (UIButton * (^reductor)(UIButton * _Nonnull, unsigned int)) {
            dispatch_barrier_async(dispatch_get_main_queue(), ^{
                dispatch_apply(5, enumerator_queue, ^(size_t index) {
                    dispatch_barrier_async(dispatch_get_main_queue(), ^{
                        reduction(reductor(button_collection[index], (unsigned int)index), (unsigned int)index);
                    });
                });
            });
        };
    };
};

= ^ (__strong UIButton * _Nonnull button_collection[5]) {
    return ^ (void(^b)(UIButton * _Nonnull)) {
        return ^ (UIButton *(^c)(unsigned int)) {
        };
    };
};

static void (^reduce)(void) = ^{
    state();
    filter(buttons)(^ (UIButton * _Nonnull button, unsigned int property) {
        printf("\n%lu\tstate\t%s\t\t", button.tag, (state_bits & (1 << property)) ? "TRUE" : "FALSE");
        printf("%lu\tselected\t%s\t\t", button.tag, (selected_bits & (1 << property)) ? "TRUE" : "FALSE");
        printf("%lu\tenabled\t%s\n", button.tag, (enabled_bits & (1 << property)) ? "TRUE" : "FALSE");
        [button setSelected:(selected_bits & (1 << property)) ? TRUE : FALSE];
        [button setHidden:(enabled_bits & (1 << property)) ? FALSE : TRUE];
    });
};

/* */

/* Is nth bit masked */

bool nth_is_set = (v & (1 << n)) != 0;
bool nth_is_set = (v >> n) & 1;

/* */

/* Core Haptics failure */

@property (nonatomic, assign) BOOL supportsHaptics;
@property (nonatomic, strong) CHHapticEngine* engine;
@property (nonatomic, strong) id<CHHapticPatternPlayer> player;

    self.supportsHaptics = CHHapticEngine.capabilitiesForHardware.supportsHaptics;
    printf("CHHapticEngine %s\n", (self.supportsHaptics) ? "supported" : "not supported");
    __autoreleasing NSError* error = nil;
    _engine = [[CHHapticEngine alloc] initAndReturnError:&error];
    printf("%s\n", (error) ? [error.localizedDescription UTF8String] : "Initialized CHHapticEngine");
    hapticDict =
        @{
         CHHapticPatternKeyPattern:
               @[ // Start of array
                 @{  // Start of first dictionary entry in the array
                     CHHapticPatternKeyEvent: @{ // Start of first item
                             CHHapticPatternKeyEventType:CHHapticEventTypeHapticTransient,
                             CHHapticPatternKeyTime:@0.5,
                             CHHapticPatternKeyEventDuration:@1.0
                             },  // End of first item
                   }, // End of first dictionary entry in the array
                ], // End of array
         }; // End of haptic dictionary

    CHHapticPattern* pattern = [[CHHapticPattern alloc] initWithDictionary:hapticDict error:&error];
    _player = [_engine createPlayerWithPattern:pattern error:&error];
    __weak ControlView * w_control_view = self;
    [_engine setResetHandler:^{
        NSLog(@"Engine RESET!");
        // Try restarting the engine again.
        __autoreleasing NSError* error = nil;
        [w_control_view.engine startAndReturnError:&error];
        if (error) {
            NSLog(@"ERROR: Engine couldn't restart!");
        }
        _player = [_engine createPlayerWithPattern:pattern error:&error];
    }];
    [_engine setStoppedHandler:^(CHHapticEngineStoppedReason reason){
        NSLog(@"Engine STOPPED!");
        switch (reason)
        {
            case CHHapticEngineStoppedReasonAudioSessionInterrupt: {
                NSLog(@"REASON: Audio Session Interrupt");
                // A phone call or notification could have come in, so take note to restart the haptic engine after the call ends. Wait for user-initiated playback.
                break;
            }
            case CHHapticEngineStoppedReasonApplicationSuspended: {
                NSLog(@"REASON: Application Suspended");
                // The user could have backgrounded your app, so take note to restart the haptic engine when the app reenters the foreground. Wait for user-initiated playback.
                break;
            }
            case CHHapticEngineStoppedReasonIdleTimeout: {
                NSLog(@"REASON: Idle Timeout");
                // The system stopped an idle haptic engine to conserve power, so restart it before your app must play the next haptic pattern.
                break;
            }
            case CHHapticEngineStoppedReasonNotifyWhenFinished: {
                printf("CHHapticEngineStoppedReasonNotifyWhenFinished\n");
                break;
            }
            case CHHapticEngineStoppedReasonEngineDestroyed: {
                printf("CHHapticEngineStoppedReasonEngineDestroyed\n");
                break;
            }
            case CHHapticEngineStoppedReasonGameControllerDisconnect: {
                printf("CHHapticEngineStoppedReasonGameControllerDisconnect\n");
                break;
            }
            case CHHapticEngineStoppedReasonSystemError: {
                NSLog(@"REASON: System Error");
                // The system faulted, so either continue without haptics or terminate the app.
                break;
            }
        }
    }];

    [_engine startWithCompletionHandler:^(NSError* returnedError) {
        if (returnedError)
            NSLog(@"--- Error starting haptic engine: %@", returnedError.debugDescription);
    }];

    [_player startAtTime:CHHapticTimeImmediate error:&error];

    [_engine stopWithCompletionHandler:^(NSError* _Nullable error) {
        if (error)
            NSLog(@"--- Error stopping haptic engine: %@", error.debugDescription);
    }];

/*
 
 */


static void (^(^(^(^(^(^(^(^draw_control_init)(__nullable dispatch_block_t))(ArcControlMeasurements * const))(ControlView *__strong))(CGRect))(CAShapeLayer *__strong))(CGContextRef __nullable))(TouchEventHandlerType))(UITouch *);
static void (^(^(^(^(^(^(^draw_control)(ArcControlMeasurements * const))(ControlView *__strong))(CGRect))(CAShapeLayer *__strong))(CGContextRef __nullable))(TouchEventHandlerType))(UITouch *);
static void (^(^(^(^(^(^draw_primary_component_init)(ControlView *__strong))(CGRect))(CAShapeLayer *__strong))(CGContextRef __nullable))(TouchEventHandlerType))(UITouch *);
static void (^(^(^(^(^draw_primary_component)(CGRect))(CAShapeLayer *__strong))(CGContextRef __nullable))(TouchEventHandlerType))(UITouch *);
static void (^(^(^(^draw_secondary_component_init)(CAShapeLayer *__strong))(CGContextRef __nullable))(TouchEventHandlerType))(UITouch *);
static void (^(^(^draw_secondary_component)(CGContextRef __nullable))(TouchEventHandlerType))(UITouch *);
static void (^(^handle_touch_control_event_init)(TouchEventHandlerType))(UITouch *);
static void (^handle_touch_control_event[TouchEventHandlerTypeDefault])(UITouch *);

static void (^(^(^(^(^(^(^(^draw_control_init)(__nullable dispatch_block_t))(ArcControlMeasurements * const))(ControlView *__strong))(CGRect))(CAShapeLayer *__strong))(CGContextRef __nullable))(TouchEventHandlerType))(UITouch *) =


^ (dispatch_block_t init) {
    if (init) init();
    return (^ (ArcControlMeasurements * const measurements) {
        return (^ (ControlView * view) {
            return (^ (CGRect rect) {
                UIButton * (^CaptureDeviceConfigurationPropertyButton)(CaptureDeviceConfigurationControlProperty) = CaptureDeviceConfigurationPropertyButtons(CaptureDeviceConfigurationControlPropertyImageValues, view);
                for (CaptureDeviceConfigurationControlProperty property = CaptureDeviceConfigurationControlPropertyTorchLevel; property <= CaptureDeviceConfigurationControlPropertyZoomFactor; property++) {
                    UIButton * button = CaptureDeviceConfigurationPropertyButton(property);
                    CGPoint center = CGPointMake(CGRectGetMidX(rect), CGRectGetMidY(rect));
                    CGFloat radius = (center.x);
//                    double x = (center.x + (radius * -cosf(2.0 * M_PI_4 * ((property) / 4.0))));
//                    double y = (center.y + (radius * -sinf(2.0 * M_PI_4 * ((property) / 4.0))));
                    double angle = 180.0 + (90.0 * ((property) / 4.0));
                    UIBezierPath * bezier_quad_curve = [UIBezierPath bezierPathWithArcCenter:CGPointMake(CGRectGetMaxX(rect), CGRectGetMaxY(rect))
                                                                                      radius:radius
                                                                                  startAngle:degreesToRadians(angle) endAngle:degreesToRadians(angle)
                                                                                   clockwise:FALSE];
                    
                    [button setCenter:[bezier_quad_curve currentPoint]];
                    static dispatch_once_t onceToken[5];
                    dispatch_once(&onceToken[property], ^{
                        [view addSubview:button];
                    });
                }
                return (^ (CAShapeLayer * __strong layer) {
                    return (^ (CGContextRef __nullable context) {
                        return (^ (TouchEventHandlerType touch_event_handler_type) {
                            [layer setLineWidth:1.0];
                            UIColor * stroke_color = (touch_event_handler_type == TouchEventHandlerTypeTouchesBegan)
                            ? [UIColor yellowCollor] : (touch_event_handler_type == TouchEventHandlerTypeTouchesMoved)
                            ? [UIColor systemGreenColor] : [UIColor blueCollor];
                            [layer setStrokeColor:stroke_color.CGColor];
                            [layer setFillColor:[UIColor clearColor].CGColor];
                            [layer setBackgroundColor:[UIColor clearColor].CGColor];
                            void(^touch_event_handler)(UITouch *) = ^ (UITouch * touch) {
                                CGPoint center = CGPointMake(CGRectGetMaxX(rect), CGRectGetMaxY(rect));
                                CGFloat radius = (center.x);
                                CGPoint touch_point = [touch preciseLocationInView:touch.view];
                                CGPoint tp = touch_point;/* CGPointMake(rescale(fmaxf(CGRectGetMinX(rect), fminf(CGRectGetMaxX(rect), touch_point.x)), CGRectGetMinX(rect), CGRectGetMaxX(rect), 0.0, 360.0),
                                                         rescale(fmaxf(CGRectGetMinY(rect), fminf(CGRectGetMaxY(rect), touch_point.y)), CGRectGetMinY(rect), CGRectGetMaxY(rect), 0.0, 360.0));*/
                                radius = sqrt(pow(tp.x - center.x, 2.0) + pow(tp.y - center.y, 2.0));
                                UIBezierPath * bezier_quad_curve = [UIBezierPath bezierPathWithArcCenter:CGPointMake(CGRectGetMaxX(rect), CGRectGetMaxY(rect))
                                                                                                  radius:radius
                                                                                              startAngle:degreesToRadians(270.0) endAngle:degreesToRadians(180.0)
                                                                                               clockwise:FALSE];
                                [layer setPath:bezier_quad_curve.CGPath];
                            };
                            void(^touch_event_handlers[3])(UITouch *) = {touch_event_handler, touch_event_handler, touch_event_handler};
                            return touch_event_handlers[1];
                        });
                    });
                });
            });
        });
    });
};

 //                /* _Atomic */ __block CFMutableBitVectorRef active_component_bits = CFBitVectorCreateMutable(kCFAllocatorDefault, 5);__block
 //                 unsigned int duration_midpoint = 15;
 //                __block long pre_animation_frame_count = ((~(1UL << duration_midpoint + 1) & (-(~(1UL << duration_midpoint + 1)))) << duration_midpoint + 1) - 1;  //
 //                /* _Atomic */ __block long active_component_bit_mask = ~active_component_bit_vector;
 //
 //                /* _Atomic */ CFMutableBitVectorRef selected = CFBitVectorCreateMutable(kCFAllocatorDefault, 5);
 //                bit_vector_ref(&selected, 5)(^ (uint32_t position) {
 //                    CFBit bit = (floor(log2(selected_property_bit_vector)) == position);
 //                    return bit;
 //                });
 //                /* _Atomic */ CFMutableBitVectorRef indicies = CFBitVectorCreateMutable(kCFAllocatorDefault, 5);
 //                integrate((long)30)(^ (long frame) {
 //                    pre_animation_frame_count >>= 1UL;
 //                    active_component_bit_mask = (((pre_animation_frame_count >> 0) & 1UL) << 0) ^ (((active_component_bit_vector >> 0) & 1UL) << 0);
 //                    bit_vector_ref(&active_component_bits, 5)(^ (uint32_t position) {
 //                        CFBit bit = (UInt32)(active_component_bit_mask & BUTTON_ARC_COMPONENT_BIT_MASK);
 //                        return bit;
 //                    });
 //
 //                    //                      printf("H: %d\t\tF: %ld\t\tS: %d\t\tA: %d\n", isBitSet(pre_animation_frame_count, 0), frame, isBitSet(active_component_bit_vector, 0), isBitSet((active_component_bit_mask & BUTTON_ARC_COMPONENT_BIT_MASK), 0));
 //                    float angle_adj = (360.0 / 30.0) * frame;
 //                    bit_vector_ref(&indicies, 5)(^ (uint32_t position) {
 //                        CFBit bit = (UInt32)((active_component_bit_mask >> 0) & 1UL) ^ !!(floor(log2(selected_property_bit_vector)) == position) ^ (((pre_animation_frame_count >> 0) & 1UL) << 0);
 //                        return bit;
 //                    });
 //                    return (^{
 //                        dispatch_barrier_async(dispatch_get_main_queue(), ^{
 //                            draw_button_arc(indicies, angle_adj);
 //                        });
 //                        return ^{
 //                            return (long)indicies;
 //                        };
 //                    }()());
 //
 //                });
 //
 //                return (^{
 //                    dispatch_barrier_async(dispatch_get_main_queue(), ^{
 //                        draw_button_arc(bit_vector_ref(&active_component_bit_vector_ref, 5)(^ (uint32_t position) {
 //                            CFBit bit = (UInt32)((active_component_bit_vector >> 0) & 1UL) ^ !!(floor(log2(selected_property_bit_vector)) == position);
 //                            return bit;
 //                        }), 0.0f);
 //                    });
 //                    return ^{
 //                        return (long)active_component_bit_vector_ref;
 //                    };
 //                }()());


__block volatile atomic_uint_fast8_t touch_property = ATOMIC_VAR_INIT(0);
typeof(touch_property) * touch_property_t = &touch_property;

uint_fast8_t current_touch_property     = (unsigned long)round(rescale(position_angle, 180.0, 270.0, 0.0, 4.0));
uint_fast8_t * current_touch_property_t = &current_touch_property;

atomic_compare_exchange_weak(touch_property_t, new_touch_property_t, new_touch_property); // atomic_exchange(touch_property_t, new_touch_property) ^ new_touch_property);
OSAtomicCompareAndSwapLong((highlighted_property_bit_vector << touch_property), (highlighted_property_bit_vector << new_touch_property), &touch_property);

typedef unsigned long v5si  __attribute__((__vector_size__(sizeof(unsigned long) * 5)));
typedef unsigned long v30si __attribute__((__vector_size__(sizeof(unsigned long) * 30)));

//
//#import "ControlView.h"
//#import "Renderer.h"
//#include <simd/simd.h>
//#import <objc/runtime.h>
//#include <simd/simd.h>
//#include <stdio.h>
//#include <math.h>
//#include <stdatomic.h>
//@import Accelerate;
//@import CoreHaptics;
//
//static NSArray<NSString *> * const CaptureDeviceConfigurationControlPropertyImageKeys = @[@"CaptureDeviceConfigurationControlPropertyTorchLevel",
//                                                                                          @"CaptureDeviceConfigurationControlPropertyLensPosition",
//                                                                                          @"CaptureDeviceConfigurationControlPropertyExposureDuration",
//                                                                                          @"CaptureDeviceConfigurationControlPropertyISO",
//                                                                                          @"CaptureDeviceConfigurationControlPropertyZoomFactor"];
//
//
//static NSArray<NSArray<NSString *> *> * const CaptureDeviceConfigurationControlPropertyImageValues = @[@[@"bolt.circle",
//                                                                                                         @"viewfinder.circle",
//                                                                                                         @"timer",
//                                                                                                         @"camera.aperture",
//                                                                                                         @"magnifyingglass.circle"],@[@"bolt.circle.fill",
//                                                                                                                                      @"viewfinder.circle.fill",
//                                                                                                                                      @"timer",
//                                                                                                                                      @"camera.aperture",
//                                                                                                                                      @"magnifyingglass.circle.fill"]];
//
//typedef enum : NSUInteger {
//    CaptureDeviceConfigurationControlStateDeselected,
//    CaptureDeviceConfigurationControlStateSelected,
//    CaptureDeviceConfigurationControlStateHighlighted
//} CaptureDeviceConfigurationControlState;
//
//static UIImageSymbolConfiguration * (^CaptureDeviceConfigurationControlPropertySymbolImageConfiguration)(CaptureDeviceConfigurationControlState) = ^ UIImageSymbolConfiguration * (CaptureDeviceConfigurationControlState state) {
//    UIImageSymbolConfiguration * symbol_point_size_weight = [UIImageSymbolConfiguration configurationWithPointSize:42.0 weight:UIImageSymbolWeightLight];
//    switch (state) {
//        case CaptureDeviceConfigurationControlStateDeselected: {
//            UIImageSymbolConfiguration * symbol_color             = [UIImageSymbolConfiguration configurationWithHierarchicalColor:[UIColor systemBlueColor]];
//            return [symbol_color configurationByApplyingConfiguration:symbol_point_size_weight];
//        }
//            break;
//        case CaptureDeviceConfigurationControlStateSelected: {
//            UIImageSymbolConfiguration * symbol_color             = [UIImageSymbolConfiguration configurationWithHierarchicalColor:[UIColor systemYellowColor]];
//            return [symbol_color configurationByApplyingConfiguration:symbol_point_size_weight];
//        }
//            break;
//        case CaptureDeviceConfigurationControlStateHighlighted: {
//            UIImageSymbolConfiguration * symbol_color             = [UIImageSymbolConfiguration configurationWithHierarchicalColor:[UIColor systemRedColor]];
//            return [symbol_color configurationByApplyingConfiguration:symbol_point_size_weight];
//        }
//            break;
//        default: {
//            UIImageSymbolConfiguration * symbol_color             = [UIImageSymbolConfiguration configurationWithHierarchicalColor:[UIColor systemYellowColor]];
//            return [symbol_color configurationByApplyingConfiguration:symbol_point_size_weight];
//        }
//            break;
//    }
//};
//
//static NSString * (^CaptureDeviceConfigurationControlPropertySymbol)(CaptureDeviceConfigurationControlProperty, CaptureDeviceConfigurationControlState) = ^ NSString * (CaptureDeviceConfigurationControlProperty property, CaptureDeviceConfigurationControlState state) {
//    return CaptureDeviceConfigurationControlPropertyImageValues[state][property];
//};
//
//static NSString * (^CaptureDeviceConfigurationControlPropertyString)(CaptureDeviceConfigurationControlProperty) = ^ NSString * (CaptureDeviceConfigurationControlProperty property) {
//    return CaptureDeviceConfigurationControlPropertyImageKeys[property];
//};
//
//static UIImage * (^CaptureDeviceConfigurationControlPropertySymbolImage)(CaptureDeviceConfigurationControlProperty, CaptureDeviceConfigurationControlState) = ^ UIImage * (CaptureDeviceConfigurationControlProperty property, CaptureDeviceConfigurationControlState state) {
//    return [UIImage systemImageNamed:CaptureDeviceConfigurationControlPropertySymbol(property, state) withConfiguration:CaptureDeviceConfigurationControlPropertySymbolImageConfiguration(state)];
//};
//
//const unsigned int capture_device_configuration_control_property_torch_level_bit = (1UL << 0);
//const unsigned int capture_device_configuration_control_property_lens_position_bit = (1UL << 1);
//const unsigned int capture_device_configuration_control_property_exposure_duration_bit = (1UL << 2);
//const unsigned int capture_device_configuration_control_property_iso_bit = (1UL << 3);
//const unsigned int capture_device_configuration_control_property_video_zoom_factor_bit = (1UL << 4);
//#define BUTTON_ARC_COMPONENT_BIT_MASK  (capture_device_configuration_control_property_torch_level_bit | capture_device_configuration_control_property_lens_position_bit | capture_device_configuration_control_property_exposure_duration_bit | capture_device_configuration_control_property_iso_bit | capture_device_configuration_control_property_video_zoom_factor_bit)
//#define TICK_WHEEL_COMPONENT_BIT_MASK (  0 << 0 |   0 << 1 |   0 << 2 |   0 << 3 |   0 << 4)
///* _Atomic */ unsigned int active_component_bit_vector     = BUTTON_ARC_COMPONENT_BIT_MASK;
///* _Atomic */ unsigned int highlighted_property_bit_vector = TICK_WHEEL_COMPONENT_BIT_MASK;
///* _Atomic */ unsigned int selected_property_bit_vector    = TICK_WHEEL_COMPONENT_BIT_MASK;
///* _Atomic */ unsigned int hidden_property_bit_vector      = TICK_WHEEL_COMPONENT_BIT_MASK;
//
//static __strong const UIButton * _Nonnull buttons[5];
//static const UIButton * (^capture_device_configuration_control_property_button)(CaptureDeviceConfigurationControlProperty) = ^ (CaptureDeviceConfigurationControlProperty property) {
//    dispatch_barrier_async(dispatch_get_main_queue(), ^{
//        [buttons[property] setSelected:(selected_property_bit_vector >> property) & 1UL];
//        [buttons[property] setHidden:(hidden_property_bit_vector >> property) & 1UL];
//        [buttons[property] setHighlighted:(highlighted_property_bit_vector >> property) & 1UL];
//    });
//
//    return (const UIButton *)buttons[property];
//};
//
//static dispatch_queue_t enumerator_queue() {
//    static dispatch_queue_t queue;
//    static dispatch_once_t onceToken;
//    dispatch_once(&onceToken, ^{
//        queue = dispatch_queue_create("enumerator_queue()", NULL);
//    });
//
//    return queue;
//};
//
//static void (^(^map)(__strong const UIButton * _Nonnull [_Nonnull 5]))(const UIButton * (^__strong)(unsigned int)) = ^ (__strong const UIButton * _Nonnull button_collection[5]) {
//    return ^ (const UIButton *(^enumeration)(unsigned int)) {
//        dispatch_barrier_async(dispatch_get_main_queue(), ^{
//            dispatch_apply(5, enumerator_queue(), ^(size_t index) {
//                dispatch_barrier_async(dispatch_get_main_queue(), ^{
//                    button_collection[index] = enumeration((unsigned int)index);
//                });
//            });
//        });
//    };
//};
//
//static uint32_t  (^(^filter)(__strong const UIButton * _Nonnull [_Nonnull 5]))(void (^__strong)(const UIButton * _Nonnull, unsigned int)) = ^ (__strong const UIButton * _Nonnull button_collection[5]) {
//    return ^ uint32_t  (void(^enumeration)(const UIButton * _Nonnull, unsigned int)) {
//        dispatch_apply(5, DISPATCH_APPLY_AUTO, ^(size_t index) {
//            enumeration(capture_device_configuration_control_property_button(index), (unsigned int)index);
//        });
//        return active_component_bit_vector;
//    };
//};
//
//
//
//
//
////static long (^(^integrate)(long))(long(^ _Nullable (^__strong)(long))(void)) = ^ (long duration) {
////    __block long frames = ~(1 << (duration + 1));
////    __block long(^cancel)(void);
////    __block long frame;
////    return ^ long (long(^ _Nullable (^__strong integrand)(long))(void)) {
////        dispatch_barrier_async(enumerator_queue(), ^{
////            dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, DISPATCH_APPLY_AUTO);
////            dispatch_source_set_timer(timer, DISPATCH_TIMER_STRICT, (1.0/duration) * NSEC_PER_SEC, 0.0 * NSEC_PER_SEC);
////            dispatch_source_set_event_handler(timer, ^{
////                frames >>= 1;
////                ((frames & 1) && ^ long {
////                    frame = (long)Log2n((unsigned int)frames);
////                    ((long)0 || (cancel = (integrand(frame)))) && cancel(); // runs a cancel handler if one was provided
////                    printf("\tframe == %ld\n", frame);
////                    return active_component_bit_vector;
////                }())
////
////                ||
////
////                ((frames | 1) &&  ^ long {
////                    dispatch_suspend(timer);
////                    printf("animation end\n");
////                    return active_component_bit_vector;
////                }());
////            });
////            printf("animation begin\t\t\t---------------\t\t\t");
////            dispatch_resume(timer);
////        });
////
////        return active_component_bit_vector;
////    };
////};
//
//
//
////void (^test)(void) = ^{
////    __block int i = 0;
////    void(^block(void(^)(void)))(void(^(^)(void))(void));
////    block(^{
////        printf("%d\n", i++);
////    })(^{
////        printf("%d\n", i++);
////        return ^{
////            printf("%d\n", i++);
////        };
////    });
////};
//
////
////void (^test2)(void) = ^{
////    void(^(^__strong blk2)(void))(long) = ^ {
////        // state change
////        return ^ (long end) {
////            // ending animation
////        };
////    };
////    void(^(^__strong blk1)(long))(void) = ^ (long start) {
////        // starting animation
////        return ^{
////            // state change
////        };
////    };
////    void (^(^(^blk3)(long))(void))(long) = ^ (long start) {
////        // starting animation
////        return ^ {
////            // state change
////            return ^ (long end) {
////                // ending animation
////            };
////        };
////    };
////
////    blk3((long)1/* start_animation */)(/* set_state */)((long)1/* end_animation */);
////    // this does not ensure a single transaction, as each block could be called individually - the output of one must be the input of another and the invoker of it, as well:
////    //          animate(starting_animation(state_change));
//////    long(^transition)(long(^(^animations)(long(^state)(void)))(void));
////    long(^transition)(long(^animate)(void(^(^state)(void))(long)));
////
////
////
////    blk1((long)1)();
////    blk2()((long)1);
////};
//
//static NSString * (^NSStringFromBitVector)(uint32_t , unsigned int) = ^ NSString * (uint32_t  bit_vector, unsigned int length) {
//    NSMutableString * bit_vector_str = [[NSMutableString alloc] initWithCapacity:length];
//    for (int property = 0; property < length; property++)
//        [bit_vector_str appendString:[NSString stringWithFormat:@"%d", (bit_vector & (1 << property)) >> property]];
//    return (NSString *)bit_vector_str;
//};
//
//int setBit(int x, unsigned char position) {
//    int mask = 1 << position;
//    return x | mask;
//}
//
//int clearBit(int x, unsigned char position) {
//    int mask = 1 << position;
//    return x & ~mask;
//}
//
//int modifyBit(int x, unsigned char position, bool newState) {
//    int mask = 1 << position;
//    int state = (int)(newState); // relies on true = 1 and false = 0
//    return (x & ~mask) | (-state & mask);
//}
//
//int flipBit(int x, unsigned char position) {
//    int mask = 1 << position;
//    return x ^ mask;
//}
//
//bool isBitSet(int x, unsigned char position) {
//    x >>= position;
//    return (x & 1) != 0;
//}
//
//int extractBit(int bit_vector, int length, int position)
//{
//    return (((1 << length) - 1) & (bit_vector >> (position - 1)));
//}
//
//typedef long (^Log2n_Block)(unsigned int);
//static Log2n_Block first_set_bit = ^ long (unsigned int property) {
//    return (property > 1) ? 1 + first_set_bit(property / 2) : 0;
//};
//
////static Log2n_Block Log2n = ^ (unsigned int bit_vector) {
////    return first_set_bit(extractBit(bit_vector, 5, 1));
////};
//
//static long (^(^reduce)(__strong const UIButton * _Nonnull [_Nonnull 5]))(void (^__strong)(const UIButton * _Nonnull, unsigned int)) = ^ (__strong const UIButton * _Nonnull button_collection[5]) {
//    return ^ long (void(^reduction)(const UIButton * _Nonnull, unsigned int)) {
//        dispatch_apply(1, DISPATCH_APPLY_AUTO, ^(size_t index) {
//            unsigned int selected_property_bit_position = first_set_bit(selected_property_bit_vector);
//            reduction(capture_device_configuration_control_property_button(selected_property_bit_position), selected_property_bit_position);
//
//        });
//        return active_component_bit_vector;
//    };
//};
//
//static long (^(^integrate)(long))(long(^ _Nullable (^__strong)(long))(CADisplayLink *)) = ^ (long duration) {
//    __block typeof(CADisplayLink *) display_link;
//    __block long frames = ~(1 << (duration + 1));
//    __block long frame;
//    __block long(^cancel)(CADisplayLink *);
//    return ^ long (long(^ _Nullable (^__strong integrand)(long))(CADisplayLink *)) {
//        display_link = [CADisplayLink displayLinkWithTarget:^{
//            frames >>= 1;
//            return
//            ((frames & 1) && ^ long {
//                frame = (long)first_set_bit((unsigned int)frames);
//                ((long)0 || (cancel = (integrand(frame)))) && cancel(display_link); // runs a cancel handler if one was provided
//                return active_component_bit_vector;
//            }())
//
//            ||
//
//            ((frames | 1) && ^ long {
//                [display_link invalidate];
//                return active_component_bit_vector;
//            }());
//        } selector:@selector(invoke)];
//        [display_link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];
//        return active_component_bit_vector;
//    };
//};
//
//typedef struct __attribute__((objc_boxable)) TransitionAnimationStruct
//{
//    unsigned int * const frame_ptr;
//    double * const center_ptr;
//    double * const radius_ptr;
//    __unsafe_unretained long(^set_state)(void);
//} TransitionAnimationStruct;
//
//static unsigned int frame;
//static double center[2] = {0.0, 0.0};
//static double radius    = 380.0;
//static long(^transition_animation)(CGPoint center, float radius); // To-Do: assign expression
//unsigned int * const frame_ptr = &frame;
//double * const center_ptr  = &center[2];
//double * const radius_ptr  = &radius;
//
//TransitionAnimationStruct
//{
//    unsigned int * const frame_ptr;
//    double * const center_ptr;
//    double * const radius_ptr;
//    __unsafe_unretained long(^transition_animation)(CGPoint center_point, float radius);
//} transitionAnimationStruct = {
//    .frame_ptr  = &frame,
//    .center_ptr = &center[2],
//    .radius_ptr = &radius,
//    .transition_animation  = ^ long (CGPoint center_point, float radius) { return (long)active_component_bit_vector; },
//};
//
//
//long (^set_state)(void (^ _Nonnull)(long (^ _Nullable)(void))) = ^ long (void (^ _Nonnull touch_handler)(long (^ _Nullable)(void))) {
//    dispatch_barrier_async(enumerator_queue(), ^{
//        active_component_bit_vector = ~active_component_bit_vector;
//
//        // converse nonimplication
//        uint32_t  selected_property_bit_mask = TICK_WHEEL_COMPONENT_BIT_MASK;
//        uint32_t  selected_property_bit_position = (first_set_bit(selected_property_bit_vector));
//        uint32_t  highlighted_property_bit_position = (first_set_bit(highlighted_property_bit_vector));
//        selected_property_bit_mask ^= (1UL << highlighted_property_bit_position) & ~active_component_bit_vector;
//        selected_property_bit_vector = (selected_property_bit_vector | selected_property_bit_mask) & ~selected_property_bit_vector;
//
//        // exclusive disjunction
//        hidden_property_bit_vector = ~active_component_bit_vector;
//        hidden_property_bit_vector = selected_property_bit_mask & ~active_component_bit_vector;
//        hidden_property_bit_vector ^= BUTTON_ARC_COMPONENT_BIT_MASK;
//        hidden_property_bit_vector ^= active_component_bit_vector;
//
//        // highlighted_reset
//        //    highlighted_property_bit_vector = ~active_component_bit_vector;
//        //    highlighted_property_bit_vector = TICK_WHEEL_COMPONENT_BIT_MASK & ~active_component_bit_vector;
//        //    highlighted_property_bit_vector ^= BUTTON_ARC_COMPONENT_BIT_MASK;
//        //    highlighted_property_bit_vector ^= active_component_bit_vector;
//
//
//
//
//
//        // To-Do: Split the animations in half, with 5 buttons exiting and one entering and vice versa
//        //        (maybe by setting state between exit and entrance)
//        //    return ^ long (CGPoint center_point, float radius) {
//        //        ((active_component_bit_vector & BUTTON_ARC_COMPONENT_BIT_MASK) &&
//        //         integrate((long)30)(^ (long frame) {
//        //            return ^ long (CADisplayLink * display_link) {
//        //                float angle_adj = (360.0 / 30.0) * frame;
//        //                filter(buttons)(^{
//        //                    return ^ (const UIButton * _Nonnull button, unsigned int index) {
//        //                        dispatch_barrier_async(dispatch_get_main_queue(), ^{
//        //                            [button setCenter:^ (float radians) {
//        //                                return CGPointMake(center_point.x - radius * -cos(radians), center_point.y - radius * -sin(radians));
//        //                            }(degreesToRadians(rescale(index, 0.0, 4.0, 180.0 + angle_adj, 270.0 + angle_adj)))];
//        //                        });
//        //                    };
//        //                }());
//        //                return (long)active_component_bit_vector;
//        //            };
//        //        }))
//        //
//        //        ||
//        //
//        //        ((active_component_bit_vector & TICK_WHEEL_COMPONENT_BIT_MASK) &&
//        //         integrate((long)30)(^ (long frame) {
//        //            return ^ long (CADisplayLink * display_link) {
//        //                float angle_adj = (360.0 / 30.0) * frame;
//        //                reduce(buttons)(^ (const UIButton * _Nonnull button, unsigned int index) {
//        //                    dispatch_barrier_async(dispatch_get_main_queue(), ^{
//        //                        [button setCenter:^ (float radians) {
//        //                            return CGPointMake(center_point.x - radius * -cos(radians), center_point.y - radius * -sin(radians));
//        //                        }(degreesToRadians(rescale(index, 0.0, 4.0, 180.0 - angle_adj, 270.0 - angle_adj)))];
//        //                    });
//        //                });
//        ////                [display_link invalidate]; // test -- remove
//        //                return (long)active_component_bit_vector;
//        //            };
//        //        }));
//        //        return (long)active_component_bit_vector;
//        //    };
//        highlighted_property_bit_vector = TICK_WHEEL_COMPONENT_BIT_MASK;
//    });
//
//    dispatch_barrier_async(enumerator_queue(), ^{ touch_handler(nil); /* the torch-level button does not position correctly when the control returns to the primary state */ });
//
//    return (long)active_component_bit_vector;
//};
//
//static void (^draw_tick_wheel)(CGContextRef, CGRect);
//static void (^(^draw_tick_wheel_init)(ControlView *, float *, float *))(CGContextRef, CGRect) = ^ (ControlView * view, float * touch_angle, float * radius) {
//    return ^ (CGContextRef ctx, CGRect rect) {
//        dispatch_barrier_sync(enumerator_queue(), ^{
//            ((active_component_bit_vector & BUTTON_ARC_COMPONENT_BIT_MASK) && ^ long (void) {
//                CGContextClearRect(ctx, rect);
//
//                return active_component_bit_vector;
//            }())
//
//            ||
//
//            ((active_component_bit_vector & TICK_WHEEL_COMPONENT_BIT_MASK) && ^ long (void) {
//                UIGraphicsBeginImageContextWithOptions(rect.size, FALSE, 1.0);
//                CGContextTranslateCTM(ctx, CGRectGetMinX(rect), CGRectGetMinY(rect));
//                for (unsigned int t = 180; t <= 270; t++) {
//                    float angle = degreesToRadians(t);
//                    float tick_height = (t == 180 || t == 270) ? 9.0 : (t % (unsigned int)round((270 - 180) / 9.0) == 0) ? 6.0 : 3.0;
//                    {
//                        CGPoint xy_outer = CGPointMake(((*radius + tick_height) * cosf(angle)),
//                                                       ((*radius + tick_height) * sinf(angle)));
//                        CGPoint xy_inner = CGPointMake(((*radius - tick_height) * cosf(angle)),
//                                                       ((*radius - tick_height) * sinf(angle)));
//                        CGContextSetStrokeColorWithColor(ctx, (t <= *touch_angle) ? [[UIColor systemGreenColor] CGColor] : [[UIColor systemRedColor] CGColor]);
//                        CGContextSetLineWidth(ctx, (t == 180 || t == 270) ? 2.0 : (t % 9 == 0) ? 1.0 : 0.625);
//                        CGContextMoveToPoint(ctx, xy_outer.x + CGRectGetMaxX(rect), xy_outer.y + CGRectGetMaxY(rect));
//                        CGContextAddLineToPoint(ctx, xy_inner.x + CGRectGetMaxX(rect), xy_inner.y + CGRectGetMaxY(rect));
//                    }
//                    CGContextStrokePath(ctx);
//                }
//                UIGraphicsEndImageContext();
//                [(ControlView *)view setNeedsDisplay];
//
//                return active_component_bit_vector;
//            }());
//        });
//    };
//};
//
//static void (^(^touch_handler)(__strong UITouch * _Nullable))(long (^ _Nullable /* set_state (for this handle_touch) */)(void (^ _Nonnull /* handle_touch (for set_state) */)(long (^ _Nullable /* set_state (a placeholder for handle_touch in this case) */)(void))));
//static void (^handle_touch)(long (^ _Nullable /* set_state (for this handle_touch) */)(void (^ _Nonnull /* handle_touch (for set_state) */)(long (^ _Nullable /* set_state (a placeholder for handle_touch in this case) */)(void))));
//static void (^(^(^touch_handler_init)(ControlView *, id<CaptureDeviceConfigurationControlPropertyDelegate>))(__strong UITouch * _Nullable))(long (^ _Nullable /* set_state (for this handle_touch) */)(void (^ _Nonnull /* handle_touch (for set_state) */)(long (^ _Nullable /* set_state (a placeholder for handle_touch in this case) */)(void)))) =  ^ (ControlView * view, id<CaptureDeviceConfigurationControlPropertyDelegate> delegate) {
//    CGPoint center_point = CGPointMake(CGRectGetMaxX(((ControlView *)view).bounds), CGRectGetMaxY(((ControlView *)view).bounds));
//    static float touch_angle;
//    static CGPoint touch_point;
//    static float radius;
//    draw_tick_wheel = draw_tick_wheel_init((ControlView *)view, &touch_angle, &radius);
//    return ^ (__strong UITouch * _Nullable touch) {
//        // get a unique identifier for the UITouch object and set global variable
//        return ^ (long (^ _Nullable state_setter)(void (^ _Nonnull /* handle_touch (for set_state) */)(long (^ _Nullable /* set_state (a placeholder for handle_touch in this case) */)(void)))) {
////            dispatch_barrier_sync(enumerator_queue(), ^{
//                touch_point = [touch locationInView:(ControlView *)view];
//                touch_point.x = fmaxf(0.0, fminf(touch_point.x, CGRectGetMaxX(((ControlView *)view).bounds)));
//                touch_point.y = fmaxf(0.0, fminf(touch_point.y, CGRectGetMaxY(((ControlView *)view).bounds)));
//
//                touch_angle = (atan2((touch_point).y - (center_point).y, (touch_point).x - (center_point).x)) * (180.0 / M_PI);
//                if (touch_angle < 0.0) touch_angle += 360.0;
//                touch_angle = fmaxf(180.0, fminf(touch_angle, 270.0));
//
//                radius = fmaxf(CGRectGetMidX(((ControlView *)view).bounds),
//                               fminf((sqrt(pow(touch_point.x - center_point.x, 2.0) + pow(touch_point.y - center_point.y, 2.0))),
//                                     CGRectGetMaxX(((ControlView *)view).bounds)));
//
//                highlighted_property_bit_vector = (((active_component_bit_vector & BUTTON_ARC_COMPONENT_BIT_MASK) & 1UL) << ((unsigned int)round(rescale(touch_angle, 180.0, 270.0, 0.0, 4.0))));
////            });
//
////            dispatch_barrier_sync(enumerator_queue(), ^{
//                ((active_component_bit_vector & BUTTON_ARC_COMPONENT_BIT_MASK)
//                 && filter(buttons)(^ (ControlView * view, float * r) {
//                    return ^ (const UIButton * _Nonnull button, unsigned int index) {
//                        dispatch_barrier_async(dispatch_get_main_queue(), ^{
//                            //                            [button setHighlighted:((active_component_bit_vector >> index) & 1UL) & (UITouchPhaseEnded ^ touch.phase) & !(touch_property ^ index) & ((highlighted_property_bit_vector >> index) & 1UL)];
//                            [button setCenter:^ (float radians) {
//                                return CGPointMake(center_point.x - *r * -cos(radians), center_point.y - *r * -sin(radians));
//                            }(degreesToRadians(rescale(index, 0.0, 4.0, 180.0, 270.0)))];
//                        });
//                    };
//                }((ControlView *)view, &radius)))
//                || ((active_component_bit_vector & TICK_WHEEL_COMPONENT_BIT_MASK)
//                    && reduce(buttons)(^ (const UIButton * _Nonnull button, unsigned int index) {
//                    dispatch_barrier_async(dispatch_get_main_queue(), ^{
//                        [button setCenter:^ (float radians) {
//                            return CGPointMake(center_point.x - radius * -cos(radians), center_point.y - radius * -sin(radians));
//                        }(degreesToRadians(touch_angle))];
//                    });
//
//                    if (index == CaptureDeviceConfigurationControlPropertyVideoZoomFactor)
//                        [delegate setCaptureDeviceConfigurationControlPropertyUsingBlock:^ (float videoZoomFactor){
//                            return ^ (AVCaptureDevice * capture_device) {
//                                [capture_device setVideoZoomFactor:videoZoomFactor];
//                            };
//                        }(rescale(touch_angle, 180.0, 270.0, 1.0, 9.0))];
//                    else if (index == CaptureDeviceConfigurationControlPropertyLensPosition)
//                        [delegate setCaptureDeviceConfigurationControlPropertyUsingBlock:^ (float lensPosition){
//                            return ^ (AVCaptureDevice * capture_device) {
//                                [capture_device setFocusModeLockedWithLensPosition:lensPosition completionHandler:nil];
//                            };
//                        }(rescale(touch_angle, 180.0, 270.0, 0.0, 1.0))];
//                    else if (index == CaptureDeviceConfigurationControlPropertyTorchLevel)
//                        [delegate setCaptureDeviceConfigurationControlPropertyUsingBlock:^ (float torchLevel){
//                            return ^ (AVCaptureDevice * capture_device) {
//                                __autoreleasing NSError * error = nil;
//                                if (([[NSProcessInfo processInfo] thermalState] != NSProcessInfoThermalStateCritical && [[NSProcessInfo processInfo] thermalState] != NSProcessInfoThermalStateSerious)) {
//                                    if (torchLevel != 0)
//                                        [capture_device setTorchModeOnWithLevel:torchLevel error:&error];
//                                    else
//                                        [capture_device setTorchMode:AVCaptureTorchModeOff];
//                                }
//                            };
//                        }(rescale(touch_angle, 180.0, 270.0, 0.0, 1.0))];
//                    else if (index == CaptureDeviceConfigurationControlPropertyISO)
//                        [delegate setCaptureDeviceConfigurationControlPropertyUsingBlock:^ (float ISO){
//                            return ^ (AVCaptureDevice * capture_device) {
//                                [capture_device setExposureModeCustomWithDuration:AVCaptureExposureDurationCurrent ISO:ISO completionHandler:nil];
//                            };
//                        }(rescale(touch_angle, 180.0, 270.0, [delegate minISO_], [delegate maxISO_]))];
//                    else if (index == CaptureDeviceConfigurationControlPropertyExposureDuration)
//                        [delegate setCaptureDeviceConfigurationControlPropertyUsingBlock:^ (float exposureDuration){
//                            return ^ (AVCaptureDevice * capture_device) {
//                                static const float kExposureDurationPower = 5;
//                                static const float kExposureMinimumDuration = 1.0/1000;
//                                double p = pow( exposureDuration, kExposureDurationPower ); // Apply power function to expand slider's low-end range
//                                double minDurationSeconds = MAX( CMTimeGetSeconds(capture_device.activeFormat.minExposureDuration ), kExposureMinimumDuration );
//                                double maxDurationSeconds = 1.0/3.0;//CMTimeGetSeconds( self.videoDevice.activeFormat.maxExposureDuration );
//                                double newDurationSeconds = p * ( maxDurationSeconds - minDurationSeconds ) + minDurationSeconds; // Scale from 0-1 slider range to actual duration
//                                [capture_device setExposureModeCustomWithDuration:CMTimeMakeWithSeconds( newDurationSeconds, 1000*1000*1000 )  ISO:AVCaptureISOCurrent completionHandler:nil];
//                            };
//                        }(rescale(touch_angle, 180.0, 270.0, 0.0, 1.0))];
//                }));
//                [((ControlView *)view) setNeedsDisplay];
////            });
//
////            dispatch_barrier_sync(enumerator_queue(), ^{
//            ((long)0 || state_setter) && state_setter(^ (long (^ _Nullable set_state)(void)) {
//                    ((active_component_bit_vector & BUTTON_ARC_COMPONENT_BIT_MASK)
//                     && filter(buttons)(^ (ControlView * view, float * r) {
//                        return ^ (const UIButton * _Nonnull button, unsigned int index) {
//                            dispatch_barrier_async(dispatch_get_main_queue(), ^{
//                                //                            [button setHighlighted:((active_component_bit_vector >> index) & 1UL) & (UITouchPhaseEnded ^ touch.phase) & !(touch_property ^ index) & ((highlighted_property_bit_vector >> index) & 1UL)];
//                                [button setCenter:^ (float radians) {
//                                    return CGPointMake(center_point.x - *r * -cos(radians), center_point.y - *r * -sin(radians));
//                                }(degreesToRadians(rescale(index, 0.0, 4.0, 180.0, 270.0)))];
//                            });
//                        };
//                    }((ControlView *)view, &radius)))
//                    || ((active_component_bit_vector & TICK_WHEEL_COMPONENT_BIT_MASK)
//                        && reduce(buttons)(^ (const UIButton * _Nonnull button, unsigned int index) {
//                        dispatch_barrier_async(dispatch_get_main_queue(), ^{
//                            [button setCenter:^ (float radians) {
//                                return CGPointMake(center_point.x - radius * -cos(radians), center_point.y - radius * -sin(radians));
//                            }(degreesToRadians(touch_angle))];
//                        });
//
//                        if (index == CaptureDeviceConfigurationControlPropertyVideoZoomFactor)
//                            [delegate setCaptureDeviceConfigurationControlPropertyUsingBlock:^ (float videoZoomFactor){
//                                return ^ (AVCaptureDevice * capture_device) {
//                                    [capture_device setVideoZoomFactor:videoZoomFactor];
//                                };
//                            }(rescale(touch_angle, 180.0, 270.0, 1.0, 9.0))];
//                        else if (index == CaptureDeviceConfigurationControlPropertyLensPosition)
//                            [delegate setCaptureDeviceConfigurationControlPropertyUsingBlock:^ (float lensPosition){
//                                return ^ (AVCaptureDevice * capture_device) {
//                                    [capture_device setFocusModeLockedWithLensPosition:lensPosition completionHandler:nil];
//                                };
//                            }(rescale(touch_angle, 180.0, 270.0, 0.0, 1.0))];
//                        else if (index == CaptureDeviceConfigurationControlPropertyTorchLevel)
//                            [delegate setCaptureDeviceConfigurationControlPropertyUsingBlock:^ (float torchLevel){
//                                return ^ (AVCaptureDevice * capture_device) {
//                                    __autoreleasing NSError * error = nil;
//                                    if (([[NSProcessInfo processInfo] thermalState] != NSProcessInfoThermalStateCritical && [[NSProcessInfo processInfo] thermalState] != NSProcessInfoThermalStateSerious)) {
//                                        if (torchLevel != 0)
//                                            [capture_device setTorchModeOnWithLevel:torchLevel error:&error];
//                                        else
//                                            [capture_device setTorchMode:AVCaptureTorchModeOff];
//                                    }
//                                };
//                            }(rescale(touch_angle, 180.0, 270.0, 0.0, 1.0))];
//                        else if (index == CaptureDeviceConfigurationControlPropertyISO)
//                            [delegate setCaptureDeviceConfigurationControlPropertyUsingBlock:^ (float ISO){
//                                return ^ (AVCaptureDevice * capture_device) {
//                                    [capture_device setExposureModeCustomWithDuration:AVCaptureExposureDurationCurrent ISO:ISO completionHandler:nil];
//                                };
//                            }(rescale(touch_angle, 180.0, 270.0, [delegate minISO_], [delegate maxISO_]))];
//                        else if (index == CaptureDeviceConfigurationControlPropertyExposureDuration)
//                            [delegate setCaptureDeviceConfigurationControlPropertyUsingBlock:^ (float exposureDuration){
//                                return ^ (AVCaptureDevice * capture_device) {
//                                    static const float kExposureDurationPower = 5;
//                                    static const float kExposureMinimumDuration = 1.0/1000;
//                                    double p = pow( exposureDuration, kExposureDurationPower ); // Apply power function to expand slider's low-end range
//                                    double minDurationSeconds = MAX( CMTimeGetSeconds(capture_device.activeFormat.minExposureDuration ), kExposureMinimumDuration );
//                                    double maxDurationSeconds = 1.0/3.0;//CMTimeGetSeconds( self.videoDevice.activeFormat.maxExposureDuration );
//                                    double newDurationSeconds = p * ( maxDurationSeconds - minDurationSeconds ) + minDurationSeconds; // Scale from 0-1 slider range to actual duration
//                                    [capture_device setExposureModeCustomWithDuration:CMTimeMakeWithSeconds( newDurationSeconds, 1000*1000*1000 )  ISO:AVCaptureISOCurrent completionHandler:nil];
//                                };
//                            }(rescale(touch_angle, 180.0, 270.0, 0.0, 1.0))];
//                    }));
////                });
//                    dispatch_async(dispatch_get_main_queue(), ^{
//                        [((ControlView *)view) setNeedsDisplay];
//                    });
//            });
//
//            //            dispatch_barrier_sync(enumerator_queue(), ^{
//            //                ((long)0 || transition) && transition(center_point, radius); //set_button_state((unsigned int)round(fmaxf(0.0, fminf((unsigned int)round(rescale(touch_angle, 180.0, 270.0, 0.0, 4.0)), 4.0))))(center_point, radius);
//            //                ((active_component_bit_vector & BUTTON_ARC_COMPONENT_BIT_MASK)
//            //                 && filter(buttons)(^ (ControlView * view, float * r) {
//            //                    return ^ (const UIButton * _Nonnull button, unsigned int index) {
//            //                        dispatch_barrier_async(dispatch_get_main_queue(), ^{
//            //                            //                            [button setHighlighted:((active_component_bit_vector >> index) & 1UL) & (UITouchPhaseEnded ^ touch.phase) & !(touch_property ^ index) & ((highlighted_property_bit_vector >> index) & 1UL)];
//            //                            [button setCenter:^ (float radians) {
//            //                                return CGPointMake(center_point.x - *r * -cos(radians), center_point.y - *r * -sin(radians));
//            //                            }(degreesToRadians(rescale(index, 0.0, 4.0, 180.0, 270.0)))]; // Consider using touch_property or index * (270 - 180) / 4 instead of rescaling
//            //                        });
//            //                    };
//            //                }((ControlView *)view, &radius)))
//            //                || ((active_component_bit_vector & TICK_WHEEL_COMPONENT_BIT_MASK)
//            //                    && reduce(buttons)(^ (const UIButton * _Nonnull button, unsigned int index) {
//            //                    dispatch_barrier_async(dispatch_get_main_queue(), ^{
//            //                        [button setCenter:^ (float radians) {
//            //                            return CGPointMake(center_point.x - radius * -cos(radians), center_point.y - radius * -sin(radians));
//            //                        }(degreesToRadians(touch_angle))];
//            //                    });
//            //                }));
//            //            });
////            [((ControlView *)view) setNeedsDisplay];
//        };
//    };
//};
//
//
//@implementation ControlView {
//        UISelectionFeedbackGenerator * haptic_feedback;
//}
//
//- (void)awakeFromNib {
//    [super awakeFromNib];
//
//    [self.layer setAffineTransform:CGAffineTransformMakeRotation(degreesToRadians(360.0))];
//    [self.layer setAffineTransform:CGAffineTransformScale(self.layer.affineTransform, -1, -1)];
//
//    [self updateStateLabels];
//        haptic_feedback = [[UISelectionFeedbackGenerator alloc] init];
//        [haptic_feedback prepare];
//
//    CGPoint default_center_point = CGPointMake(CGRectGetMaxX(((ControlView *)self).bounds), CGRectGetMaxY(((ControlView *)self).bounds));
//    float default_radius       = CGRectGetMidX(self.bounds);
//
//    map(buttons)(^ const UIButton * (unsigned int index) {
//        const UIButton * button;
//        [button = [const UIButton new] setTag:index];
//        [button setImage:[UIImage systemImageNamed:CaptureDeviceConfigurationControlPropertyImageValues[0][index] withConfiguration:CaptureDeviceConfigurationControlPropertySymbolImageConfiguration(CaptureDeviceConfigurationControlStateDeselected)] forState:UIControlStateNormal];
//        [button setImage:[UIImage systemImageNamed:CaptureDeviceConfigurationControlPropertyImageValues[1][index] withConfiguration:CaptureDeviceConfigurationControlPropertySymbolImageConfiguration(CaptureDeviceConfigurationControlStateSelected)] forState:UIControlStateSelected];
//        [button setImage:[UIImage systemImageNamed:CaptureDeviceConfigurationControlPropertyImageValues[1][index] withConfiguration:CaptureDeviceConfigurationControlPropertySymbolImageConfiguration(CaptureDeviceConfigurationControlStateHighlighted)] forState:UIControlStateHighlighted];
//
//        //        [button setTitle:[NSString stringWithFormat:@"%lu - %lu",
//        //                          (Log2n(selected_property_bit_vector)), (Log2n(highlighted_property_bit_vector))] forState:UIControlStateNormal];
//
//
//        [button sizeToFit];
//
//        float angle = rescale(index, 0.0, 4.0, 180.0, 270.0);
//        NSNumber * button_angle = [NSNumber numberWithFloat:angle];
//        objc_setAssociatedObject (button,
//                                  (void *)index,
//                                  button_angle,
//                                  OBJC_ASSOCIATION_RETAIN);
//
//        [button setUserInteractionEnabled:FALSE];
//        void (^eventHandlerBlockTouchUpInside)(void) = ^{
//            NSNumber * associatedObject = (NSNumber *)objc_getAssociatedObject (button, (void *)index);
////            printf("%s\n", [[associatedObject stringValue] UTF8String]);
//        };
//        objc_setAssociatedObject(button, @selector(invoke), eventHandlerBlockTouchUpInside, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
//        [button addTarget:eventHandlerBlockTouchUpInside action:@selector(invoke) forControlEvents:UIControlEventTouchUpInside];
//        [self addSubview:button];
//        angle = degreesToRadians(angle);
//        [button setCenter:[[UIBezierPath bezierPathWithArcCenter:default_center_point radius:default_radius startAngle:angle endAngle:angle clockwise:FALSE] currentPoint]];
//        return button;
//    });
//
//    touch_handler = touch_handler_init((ControlView *)self, self.captureDeviceConfigurationControlPropertyDelegate); // touch_handler_init(self, self.captureDeviceConfigurationControlPropertyDelegate);
//}
//
//- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {
//    dispatch_barrier_sync(enumerator_queue(), ^{ (handle_touch = touch_handler(touches.anyObject))(nil); });
//    dispatch_barrier_sync(enumerator_queue(), ^{ [self updateStateLabels]; });
//}
//
//- (void)touchesMoved:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {
//    dispatch_barrier_sync(enumerator_queue(), ^{ handle_touch(nil); });
//    dispatch_barrier_sync(enumerator_queue(), ^{ [self updateStateLabels]; });
//}
//
//- (void)touchesEnded:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {
//    dispatch_barrier_sync(enumerator_queue(), ^{ handle_touch(set_state); });
//    dispatch_barrier_sync(enumerator_queue(), ^{ [self updateStateLabels]; });
//}
//
//- (void)touchesCancelled:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {
//    dispatch_barrier_sync(enumerator_queue(), ^{
//        [self setUserInteractionEnabled:FALSE];
//    });
//    dispatch_barrier_sync(enumerator_queue(), ^{
//        handle_touch(set_state);
//    });
//    dispatch_barrier_sync(enumerator_queue(), ^{
//        [self setUserInteractionEnabled:TRUE];
//    });
//}
//
//- (void)drawRect:(CGRect)rect {
//    draw_tick_wheel(UIGraphicsGetCurrentContext(), rect);
//    // To-Do: only "click" when a new value is selected - not every time drawRect is called
//        [haptic_feedback selectionChanged];
//        [haptic_feedback prepare];
//}
//
//- (void)updateStateLabels {
//    [self.stateBitVectorLabel setText:NSStringFromBitVector(active_component_bit_vector, 5)];
//    [self.highlightedBitVectorLabel setText:NSStringFromBitVector(highlighted_property_bit_vector, 5)];
//    [self.selectedBitVectorLabel setText:NSStringFromBitVector(selected_property_bit_vector, 5)];
//    [self.hiddenBitVectorLabel setText:NSStringFromBitVector(hidden_property_bit_vector, 5)];
//}
//
//@end

/*
    Block pointer to void(^)(void) block
 */

void (^blk)(void) = ^{
    printf("blk\n");
};
void (^const __strong * blk_t)(void) = &blk;    // Initializes a block pointer to blk using the address of blk
(*blk_t)();                                     // prints 'blk' to the console


/*
    Block returning pointer to void(^)(void) block
 */

const void * (^const __strong blk_ptr)(const void (^const __strong)(void)) = ^ (const void(^const __strong blk_ptr_t)(void)) { // Initializes block pointer blk_ptr using block parameter blk_ptr_t
    printf("blk_ptr_t\n");
    return Block_copy((const void *)CFBridgingRetain(blk_ptr_t));
};
((__bridge const void(^const __strong)(void))(blk_ptr(CFBridgingRelease((__bridge CFTypeRef _Nullable)(blk)))))(); // Returns a pointer to blk_ptr_t (prints 'blk_ptr_t' to the console) using blk_ptr and invokes blk (prints 'blk' to the console)


/*
    Block returning pointer to a int(^)(int) block. Similar to an adaptable functor (nested functions with varying return types and arguments) used in generic programming.
 */

int (^int_blk)(int) = ^ (int i) {
    printf("2 == %d\n", i);
    return (int)2;
};
const void * (^const __strong int_blk_ptr)(const int (^const __strong)(int)) = ^ (const int(^const __strong int_blk_ptr_t)(int)) { // Initializes block pointer blk_ptr using block parameter blk_ptr_t
    printf("int_blk_ptr\n");
    return Block_copy((const void *)CFBridgingRetain(int_blk_ptr_t));
};
((__bridge const int(^const __strong)(int))(int_blk_ptr(CFBridgingRelease((__bridge CFTypeRef _Nullable)(int_blk)))))((int)2); // Returns a pointer to int_blk_ptr_t (prints 'int_blk_ptr' to the console) using int_blk_ptr and invokes blk (prints 'i == 1' to the console)

//


/*
 
 
 */

    unsigned long (^(^test)(UITouchPhase))(const UIButton __strong * _Nonnull)  = ^ (UITouchPhase touch_phase) {
        //        __block UIDynamicAnimator * dynamic_animator = [[UIDynamicAnimator alloc] initWithReferenceView:view];
        //        __block UISnapBehavior * snap_behavior;
        //        [snap_behavior setDamping:1.0];
        return ^  (unsigned long(^invoke)(const UIButton __strong * _Nonnull)) {
            return (^{
                //                [dynamic_animator removeAllBehaviors];
                !!(((~selected_property_bit_vector & active_component_bit_vector) ^ selected_property_bit_vector) >> 0) && invoke(buttons[0]);
                !!(((~selected_property_bit_vector & active_component_bit_vector) ^ selected_property_bit_vector) >> 1) && invoke(buttons[1]);
                !!(((~selected_property_bit_vector & active_component_bit_vector) ^ selected_property_bit_vector) >> 2) && invoke(buttons[2]);
                !!(((~selected_property_bit_vector & active_component_bit_vector) ^ selected_property_bit_vector) >> 3) && invoke(buttons[3]);
                !!(((~selected_property_bit_vector & active_component_bit_vector) ^ selected_property_bit_vector) >> 4) && invoke(buttons[4]);
                return ^{
                    return invoke;
                };
            }()());
        }(^ unsigned long (const UIButton __strong * _Nonnull button) {
            dispatch_async(dispatch_get_main_queue(), ^{
                [button setHighlighted:(highlighted_property_bit_vector >> button.tag) & 1UL];
                [button setSelected:(selected_property_bit_vector >> button.tag) & 1UL];
                [button setHidden:(hidden_property_bit_vector >> button.tag) & 1UL];
                ((active_component_bit_vector & BUTTON_ARC_COMPONENT_BIT_MASK) && angle_from_point(point_from_angle(rescale(button.tag, 0.0, 4.0, 180.0, 270.0))));
                (((selected_property_bit_vector >> button.tag) & 1UL) && (set_configuration_phase(touch_phase))(configure_torch_level(rescale(angle, 180.0, 270.0, 0.0, 1.0))));
                //                (touch_phase & UITouchPhaseBegan && ^{
                //                    snap_behavior = [[UISnapBehavior alloc] initWithItem:button snapToPoint:button_center];
                //                    [dynamic_animator addBehavior:snap_behavior];
                //                    return TRUE_BIT;
                //                });
                [button setCenter:point_from_angle(angle + angle_offset)];
            });
            return button.tag;
        });
    };

/*
 
 
 */


    unsigned long (^(^testes)(UITouchPhase))(const UIButton __strong * _Nonnull)  = ^ (UITouchPhase touch_phase) {
        static float step;
        step = (360.0 / 60.0);
        angle_offset = 0;
        return ^  (unsigned long(^post_animation)(const UIButton __strong * _Nonnull)) {
            return (^{
                post_animation(buttons[0]);
                return ^{
                    return post_animation;
                };
            }()());
        }(^ unsigned long (const UIButton __strong * _Nonnull button) {
            return ^ (unsigned long(^asdf)(const UIButton __strong * _Nonnull button)) {
                printf("----1---\n");
                return asdf(button);
            }(^ unsigned long (const UIButton __strong * _Nonnull button) {
                integrate((long)30)(^ (CADisplayLink * display_link, long frame) {
                    angle_offset += step;
                    printf("A-%d\t\tangle_offset == %f\n", frame, angle_offset);
                   return ^ long (CADisplayLink * display_link, long frame) {
                       angle_offset += step;
                       printf("B-%d\t\tangle_offset == %f\n", frame, angle_offset);
                       return frame;
                   };
                });
                return button.tag;
            });
        });
    };
